
## WebAssembly 指令表

1. 常数指令
2. 算术运算指令
3. 位运算指令
4. 变量访问指令
5. 内存访问指令
6. 比较指令
7. 类型转换指令
8. 控制流指令
9. 其他指令

### 1. 常数指令

|    指令    | 描述 |
| ---------- | --- |
| i32.const x|  在栈上压入值为x的i32值 |
| i64.const x|  在栈上压入值为x的i64值 |
| f32.const x|  在栈上压入值为x的f32值 |
| f64.const x|  在栈上压入值为x的f64值 |

### 2. 算术指令

算术运算指令的返回值的类型都与指令前缀类型一致

|    指令    | 描述 |
| ---------- | --- |
| i32.add | i32求和，从栈顶依次弹出1个i32的值 a 、1个i32的值b，计算a+b的值压入栈 |
| i32.sub | i32求差，从栈顶依次弹出1个i32的值a、1个i32的值b，计算b-a的值压入栈 |
| i32.mul | i32求积，从栈顶依次弹出1个i32的值a、1个i32的值b，计算a*b的值压入栈 |
| i32.div_s	| i32有符号求商，从栈顶依次弹出1个i32的值a、1个i32的值b，按有符号整数计算b/a的值压入栈 |
| i32.div_u	| i32无符号求商，从栈顶依次弹出1个i32的值a、1个i32的值b，按无符号整数计算b/a的值压入栈 |
| i32.rem_s | i32有符号求余，从栈顶依次弹出1个i32的值a、1个i32的值b，按有符号整数计算b%a的值压入栈 |
| i32.rem_u | i32无符号求余，从栈顶依次弹出1个i32的值a、1个i32的值b，按无符号整数计算b%a的值压入栈 |
| i64.add	| i64求和，从栈顶依次弹出1个i64的值a、1个i64的值b，计算a+b的值压入栈 |
| i64.sub	| i64求差，从栈顶依次弹出1个i64的值a、1个i64的值b，计算b-a的值压入栈 |
| i64.mul   | i64求积，从栈顶依次弹出1个i64的值a、1个i64的值b，计算a*b的值压入栈 |
| i64.div_s	| i64有符号求商，从栈顶依次弹出1个i64的值a、1个i64的值b，按有符号整数计算b/a的值压入栈 |
| i64.div_u	| i64无符号求商，从栈顶依次弹出1个i64的值a、1个i64的值b，按无符号整数计算b/a的值压入栈 |
| i64.rem_s	| i64有符号求余，从栈顶依次弹出1个i64的值a、1个i64的值b，按有符号整数计算b%a的值压入栈 |
| i64.rem_u	| i64无符号求余，从栈顶依次弹出1个i64的值a、1个i64的值b，按无符号整数计算b%a的值压入栈 |
| f32.abs   | f32求绝对值，从栈顶弹出1个f32的值v，将其符号位置为0后压入栈 |
| f32.neg	| f32求反，从栈顶弹出1个f32的值v，将其符号位取反后压入栈 |
| f32.ceil  | f32向上取整，从栈顶弹出1个f32的值v，将最接近v且不小于v的整数转为f32后压入栈 |
| f32.floor | f32向下取整，从栈顶弹出1个f32的值v，将最接近v且不大于v的整数转为f32后压入栈 |
| f32.trunc | f32向0取整，从栈顶弹出1个f32的值v，丢弃其小数部分，保留整数部分转为f32后压入栈 |
| f32.nearest | f32向最接近的整数取整，从栈顶弹出1个f32的值v，将最接近v的整数值转为f32后压入栈 |
| f32.sqrt    | f32求平方根，从栈顶弹出1个f32的值v，将其平方根压入栈 |
| f32.add     | f32求和，从栈顶依次弹出1个f32的值a、1个f32的值b，计算a+b的值压入栈 |
| f32.sub     | f32求差，从栈顶依次弹出1个f32的值a、1个f32的值b，计算b-a的值压入栈 |
| f32.mul     | f32求积，从栈顶依次弹出1个f32的值a、1个f32的值b，计算a*b的值压入栈 |
| f32.div     | f32求商，从栈顶依次弹出1个f32的值a、1个f32的值b，计算b/a的值压入栈 |
| f32.min     | f32取最小值，从栈顶依次弹出2个f32的值，取其中较小者压入栈。若任一操作数为NaN，则结果为NaN。对此指令，-0小于+0。 |
| f32.max    | f32取最大值，从栈顶依次弹出2个f32的值，取其中较大者压入栈。若任一操作数为NaN，则结果为NaN。对此指令，-0小于+0。 |
| f32.copysign | f32取符号位，从栈顶依次弹出1个f32的值a、1个f32的值b，取a的符号位覆盖b的符号位后将b压入栈 |
| f64.abs    | f64求绝对值，从栈顶弹出1个f64的值v，将其符号位置为0后压入栈 |
| f64.neg    | f64求反，从栈顶弹出1个f64的值v，将其符号位取反后压入栈 |
| f64.ceil   | f64向上取整，从栈顶弹出1个f64的值v，将最接近v且不小于v的整数转为f64后压入栈 |
| f64.floor  | f64向下取整，从栈顶弹出1个f64的值v，将最接近v且不大于v的整数转为f64后压入栈 |
| f64.trunc  | f64向0取整，从栈顶弹出1个f64的值v，丢弃其小数部分，保留整数部分转为f64后压入栈 |
| f64.nearest | f64向最接近的整数取整，从栈顶弹出1个f64的值v，将最接近v的整数值转为f64后压入栈 |
| f64.sqrt    | f64求平方根，从栈顶弹出1个f64的值v，将其平方根压入栈 |
| f64.add     | f64求和，从栈顶依次弹出1个f64的值a、1个f64的值b，计算a+b的值压入栈 |
| f64.sub     | f64求差，从栈顶依次弹出1个f64的值a、1个f64的值b，计算b-a的值压入栈 |
| f64.mul     | f64求积，从栈顶依次弹出1个f64的值a、1个f64的值b，计算a*b的值压入栈 |
| f64.div     | f64求商，从栈顶依次弹出1个f64的值a、1个f64的值b，计算b/a的值压入栈 |
| f64.min     | f64取最小值，从栈顶依次弹出2个f64的值，取其中较小者压入栈。若任一操作数为NaN，则结果为NaN。对此指令，-0小于+0。|
| f64.max     | f64取最大值，从栈顶依次弹出2个f64的值，取其中较大者压入栈。若任一操作数为NaN，则结果为NaN。对此指令，-0小于+0。|
| f64.copysign | f64取符号位，从栈顶依次弹出1个f64的值a、1个f64的值b，取a的符号位覆盖b的符号位后将b压入栈 |

