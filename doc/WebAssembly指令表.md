
## WebAssembly 指令表

1. 常数指令
2. 算术运算指令
3. 位运算指令
4. 变量访问指令
5. 内存访问指令
6. 比较指令
7. 类型转换指令
8. 控制流指令
9. 其他指令

### 1. 常数指令

|    指令    | 描述 |
| ---------- | --- |
| i32.const x|  在栈上压入值为x的i32值 |
| i64.const x|  在栈上压入值为x的i64值 |
| f32.const x|  在栈上压入值为x的f32值 |
| f64.const x|  在栈上压入值为x的f64值 |

### 2. 算术指令

算术运算指令的返回值的类型都与指令前缀类型一致

|    指令    | 描述 |
| ---------- | --- |
| i32.add | i32求和，从栈顶依次弹出1个i32的值 a 、1个i32的值b，计算a+b的值压入栈 |
| i32.sub | i32求差，从栈顶依次弹出1个i32的值a、1个i32的值b，计算b-a的值压入栈 |
| i32.mul | i32求积，从栈顶依次弹出1个i32的值a、1个i32的值b，计算a*b的值压入栈 |
| i32.div_s	| i32有符号求商，从栈顶依次弹出1个i32的值a、1个i32的值b，按有符号整数计算b/a的值压入栈 |
| i32.div_u	| i32无符号求商，从栈顶依次弹出1个i32的值a、1个i32的值b，按无符号整数计算b/a的值压入栈 |
| i32.rem_s | i32有符号求余，从栈顶依次弹出1个i32的值a、1个i32的值b，按有符号整数计算b%a的值压入栈 |
| i32.rem_u | i32无符号求余，从栈顶依次弹出1个i32的值a、1个i32的值b，按无符号整数计算b%a的值压入栈 |
| i64.add	| i64求和，从栈顶依次弹出1个i64的值a、1个i64的值b，计算a+b的值压入栈 |
| i64.sub	| i64求差，从栈顶依次弹出1个i64的值a、1个i64的值b，计算b-a的值压入栈 |
| i64.mul   | i64求积，从栈顶依次弹出1个i64的值a、1个i64的值b，计算a*b的值压入栈 |
| i64.div_s	| i64有符号求商，从栈顶依次弹出1个i64的值a、1个i64的值b，按有符号整数计算b/a的值压入栈 |
| i64.div_u	| i64无符号求商，从栈顶依次弹出1个i64的值a、1个i64的值b，按无符号整数计算b/a的值压入栈 |
| i64.rem_s	| i64有符号求余，从栈顶依次弹出1个i64的值a、1个i64的值b，按有符号整数计算b%a的值压入栈 |
| i64.rem_u	| i64无符号求余，从栈顶依次弹出1个i64的值a、1个i64的值b，按无符号整数计算b%a的值压入栈 |
| f32.abs   | f32求绝对值，从栈顶弹出1个f32的值v，将其符号位置为0后压入栈 |
| f32.neg	| f32求反，从栈顶弹出1个f32的值v，将其符号位取反后压入栈 |
| f32.ceil  | f32向上取整，从栈顶弹出1个f32的值v，将最接近v且不小于v的整数转为f32后压入栈 |
| f32.floor | f32向下取整，从栈顶弹出1个f32的值v，将最接近v且不大于v的整数转为f32后压入栈 |
| f32.trunc | f32向0取整，从栈顶弹出1个f32的值v，丢弃其小数部分，保留整数部分转为f32后压入栈 |
| f32.nearest | f32向最接近的整数取整，从栈顶弹出1个f32的值v，将最接近v的整数值转为f32后压入栈 |
| f32.sqrt    | f32求平方根，从栈顶弹出1个f32的值v，将其平方根压入栈 |
| f32.add     | f32求和，从栈顶依次弹出1个f32的值a、1个f32的值b，计算a+b的值压入栈 |
| f32.sub     | f32求差，从栈顶依次弹出1个f32的值a、1个f32的值b，计算b-a的值压入栈 |
| f32.mul     | f32求积，从栈顶依次弹出1个f32的值a、1个f32的值b，计算a*b的值压入栈 |
| f32.div     | f32求商，从栈顶依次弹出1个f32的值a、1个f32的值b，计算b/a的值压入栈 |
| f32.min     | f32取最小值，从栈顶依次弹出2个f32的值，取其中较小者压入栈。若任一操作数为NaN，则结果为NaN。对此指令，-0小于+0。 |
| f32.max    | f32取最大值，从栈顶依次弹出2个f32的值，取其中较大者压入栈。若任一操作数为NaN，则结果为NaN。对此指令，-0小于+0。 |
| f32.copysign | f32取符号位，从栈顶依次弹出1个f32的值a、1个f32的值b，取a的符号位覆盖b的符号位后将b压入栈 |
| f64.abs    | f64求绝对值，从栈顶弹出1个f64的值v，将其符号位置为0后压入栈 |
| f64.neg    | f64求反，从栈顶弹出1个f64的值v，将其符号位取反后压入栈 |
| f64.ceil   | f64向上取整，从栈顶弹出1个f64的值v，将最接近v且不小于v的整数转为f64后压入栈 |
| f64.floor  | f64向下取整，从栈顶弹出1个f64的值v，将最接近v且不大于v的整数转为f64后压入栈 |
| f64.trunc  | f64向0取整，从栈顶弹出1个f64的值v，丢弃其小数部分，保留整数部分转为f64后压入栈 |
| f64.nearest | f64向最接近的整数取整，从栈顶弹出1个f64的值v，将最接近v的整数值转为f64后压入栈 |
| f64.sqrt    | f64求平方根，从栈顶弹出1个f64的值v，将其平方根压入栈 |
| f64.add     | f64求和，从栈顶依次弹出1个f64的值a、1个f64的值b，计算a+b的值压入栈 |
| f64.sub     | f64求差，从栈顶依次弹出1个f64的值a、1个f64的值b，计算b-a的值压入栈 |
| f64.mul     | f64求积，从栈顶依次弹出1个f64的值a、1个f64的值b，计算a*b的值压入栈 |
| f64.div     | f64求商，从栈顶依次弹出1个f64的值a、1个f64的值b，计算b/a的值压入栈 |
| f64.min     | f64取最小值，从栈顶依次弹出2个f64的值，取其中较小者压入栈。若任一操作数为NaN，则结果为NaN。对此指令，-0小于+0。|
| f64.max     | f64取最大值，从栈顶依次弹出2个f64的值，取其中较大者压入栈。若任一操作数为NaN，则结果为NaN。对此指令，-0小于+0。|
| f64.copysign | f64取符号位，从栈顶依次弹出1个f64的值a、1个f64的值b，取a的符号位覆盖b的符号位后将b压入栈 |


### 3. 位运算指令：
位运算的返回值的类型都与其指令前缀类型一致

|    指令    | 描述 |
| ---------- | --- |
| i32.clz   | i32求高位开始连续0的个数，从栈顶弹出1个i32的值v，计算从v的二进制的最高位起，连续为0的位数个数k并压入栈 |
| i32.ctz   | i32求低位开始连续0的个数，从栈顶弹出1个i32的值v，计算从v的二进制的最低位起，连续为0的位数个数k并压入栈 |
| i32.popcnt | i32求1的位数个数，从栈顶弹出一个i32的值v，计算v的二进制值中为1的位数个数k并压入栈 |
| i32.and | i32按位与，从栈顶依次弹出1个i32的值a、1个i32的值b，计算a&b的值压入栈 |
| i32.or  | i32按位或，从栈顶依次弹出1个i32的值a、1个i32的值b，计算a|b的值压入栈 |
| i32.xor | i32按位异或，从栈顶依次弹出1个i32的值a、1个i32的值b，计算a^b的值压入栈 |
| i32.shl | i32左移，从栈顶依次弹出1个i32的值a、1个i32的值b，将b左移a位的值压入栈 |
| i32.shr_s | i32数学右移，从栈顶依次弹出1个i32的值a、1个i32的值b，将b数学右移a位的值压入栈（数学右移过程中符号位不变） |
| i32.shr_u | i32逻辑右移，从栈顶依次弹出1个i32的值a、1个i32的值b，将b逻辑右移a位的值压入栈 |
| i32.rotl  | i32循环左移，从栈顶依次弹出1个i32的值a、1个i32的值b，将b循环左移a位的值压入栈（循环左移中最高位移到最低位）|
| i32.rotr  | i32循环右移，从栈顶依次弹出1个i32的值a、1个i32的值b，将b循环右移a位的值压入栈（循环右移中最低位移到最高位）|
| i64.clz   | i64求高位开始连续0的个数，从栈顶弹出1个i64的值v，计算从v的二进制的最高位起，连续为0的位数个数k并压入栈 |
| i64.ctz   | i64求低位开始连续0的个数，从栈顶弹出1个i64的值v，计算从v的二进制的最低位起，连续为0的位数个数k并压入栈 |
| i64.popcnt | i64求1的位数个数，从栈顶弹出1个i64的值v，计算v的二进制值中为1的位数个数k并压入栈 |
| i64.and | i64按位与，从栈顶依次弹出1个i64的值a、1个i64的值b，计算a&b的值压入栈 |
| i64.or | i64按位或，从栈顶依次弹出1个i64的值a、1个i64的值b，计算a|b的值压入栈 |
| i64.xor | i64按位异或，从栈顶依次弹出1个i64的值a、1个i64的值b，计算a^b的值压入栈 |
| i64.shl | i64左移，从栈顶依次弹出1个i64的值a、1个i64的值b，将b左移a位的值压入栈 |
| i64.shr_s | i64数学右移，从栈顶依次弹出1个i64的值a、1个i64的值b，将b数学右移a位的值压入栈（数学右移过程中符号位不变） |
| i64.shr_u | i64逻辑右移，从栈顶依次弹出1个i64的值a、1个i64的值b，将b逻辑右移a位的值压入栈 |
| i64.rotl | i64循环左移，从栈顶依次弹出1个i64的值a、1个i64的值b，将b循环左移a位的值压入栈（循环左移中最高位移到最低位）|
| i64.rotr | i64循环右移，从栈顶依次弹出1个i64的值a、1个i64的值b，将b循环右移a位的值压入栈（循环右移中最低位移到最高位）|

### 4. 变量访问指令

|    指令     | 描述 |
| ----------  | --- |
| local.get x |  将x指定的局部变量的值压入栈，其中x为局部变量的索引或别名 |
| local.set x |  从栈顶弹出1个值，并存入指定的局部变量，x为局部变量的索引或别名 |
| local.tee x |  将栈顶的值存入x指定的局部变量，值保留在栈顶，x为局部变量的索引或别名 |
| global.get x |  将x指定的全局变量的值压入栈，其中x为全局变量的索引或别名 |
| global.set x |  从栈顶弹出1个值，并存入指定的全局变量，x为全局变量的索引或别名，该变量必须是可写全局变量 |
	
### 5. 内存访问指令

|    指令     | 描述 |
| ----------  | --- |
| i32.load offset=t align=a | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取1个i32的值压入栈。a为地址对齐值，取值1、2、4、8，默认4 |
| i64.load offset=t align=a | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取1个i64的值压入栈。a为地址对齐值，取值1、2、4、8，默认8 |
| f32.load offset=t align=a | 从栈顶弹出1个f32的值addr，从内存中的addr+t偏移处读取1个f32的值压入栈。a为地址对齐值，取值1、2、4、8，默认4 |
| f64.load offset=t align=a | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取1个f64的值压入栈。a为地址对齐值，取值1、2、4、8，默认8 |

上述指令中，offset=t可省略，默认为0；align=a 也可省略，默认值按表中给出值。

|    指令     | 描述 |
| ----------  | --- |
| i32.load8_s offset=t align=a | 从栈顶弹出1个i32的值addr， 从内存中的addr+t偏移处读取1字节，并按有符合整数拓展为i32压入栈。a为地址对齐值，取值1、2、4、8 |
| i32.load8_u offset=t align=a | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取1字节，并按无符号整数扩展为i32压入栈。a为地址对齐值，取值1、2、4、8，默认1 |
| i32.load16_s offset=t align=a | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取2字节，并按有符号整数扩展为i32压入栈。a为地址对齐值，取值1、2、4、8，默认2 |
| i32.load16_u offset=t align=a | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取2字节，并按无符号整数扩展为i32压入栈。a为地址对齐值，取值1、2、4、8，默认2 |
| i64.load8_s offset=t align=a  | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取1字节，并按有符号整数扩展为i64压入栈。a为地址对齐值，取值1、2、4、8，默认1 |
| i64.load8_u offset=t align=a  | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取1字节，并按无符号整数扩展为i64压入栈。a为地址对齐值，取值1、2、4、8，默认1 |
| i64.load16_s offset=t align=a | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取2字节，并按有符号整数扩展为i64压入栈。a为地址对齐值，取值1、2、4、8，默认2 |
| i64.load16_u offset=t align=a | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取2字节，并按无符号整数扩展为i64压入栈。a为地址对齐值，取值1、2、4、8，默认2 |
| i64.load32_s offset=t align=a | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取2字节，并按有符号整数扩展为i64压入栈。a为地址对齐值，取值1、2、4、8，默认4 |
| i64.load32_u offset=t align=a | 从栈顶弹出1个i32的值addr，从内存中的addr+t偏移处读取2字节，并按无符号整数扩展为i64压入栈。a为地址对齐值，取值1、2、4、8，默认4 |

上述指令中，有符号整数扩展为符号位扩展至最高位，其余填充0；无符号整数扩展为高位填充0。offset=t可省略，默认为0；align=a 也可省略，默认值按表中给出值。

|    指令     | 描述 |
| ----------  | --- |
| i32.store offset=t align=a | 从栈顶依次弹出1个i32的值value、1个i32的值addr，在内存的addr+t偏移处写入value。a为地址对齐值，取值1、2、4、8，默认4 |
| i64.store offset=t align=a | 从栈顶依次弹出1个i64的值value、1个i32的值addr，在内存的addr+t偏移处写入value。a为地址对齐值，取值1、2、4、8，默认8 |
| f32.store offset=t align=a | 从栈顶依次弹出1个f32的值value、1个i32的值addr，在内存的addr+t偏移处写入value。a为地址对齐值，取值1、2、4、8，默认4 |
| f64.store offset=t align=a | 从栈顶依次弹出1个f64的值value、1个i32的值addr，在内存的addr+t偏移处写入value。a为地址对齐值，取值1、2、4、8，默认8 |

上述指令中，offset=t可省略，默认为0；align=a 也可省略，默认值按表中给出值。

|    指令     | 描述 |
| ----------  | --- |
| i32.store8 offset=t align=a  | 从栈顶依次弹出1个i32的值value、1个i32的值addr，在内存的 addr+t 偏移处写入value低8位，即1个字节。a为地址对齐值，取值1、2、4、8，默认1 |
| i32.store16 offset=t align=a | 从栈顶依次弹出1个i32的值value、1个i32的值addr，在内存的addr+t偏移处写入value低16位，即2个字节。a为地址对齐值，取值1、2、4、8，默认2 |
| i64.store8 offset=t align=a  | 从栈顶依次弹出1个i64的值value、1个i32的值addr，在内存的addr+t偏移处写入value低8位，即1个字节。a为地址对齐值，取值1、2、4、8，默认1 |
| i64.store16 offset=t align=a | 从栈顶依次弹出1个i64的值value、1个i32的值addr，在内存的addr+t偏移处写入value低16位，即2个字节。a为地址对齐值，取值1、2、4、8，默认2 |
| i64.store32 offset=t align=a | 从栈顶依次弹出1个i64的值value、1个i32的值addr，在内存的addr+t偏移处写入value低32位，即4个字节。a为地址对齐值，取值1、2、4、8，默认4 |

上述指令中，offset=t可省略，默认为0；align=a 也可省略，默认值按表中给出值。

|    指令     | 描述 |
| ----------  | --- |
| memory.size | 当前内存容量（i32）压入栈，以页为单位，1页为64kb，65536字节 |
| memory.grow | 如当前内存容量为c，从栈顶弹出1个i32的值v，将内存的容量扩大为c+v，以页为单位。如果扩容成功，将i32类型的c压入栈，否则将-1压入栈。内存新扩容的部分全部初始化为0 |

### 6. 比较指令

比较指令的返回值均为i32，返回值压入栈顶。 

|    指令     | 描述 |
| ----------  | --- |
| i32.eqz  | 从栈顶弹出1个i32的值v，若v为0，则在栈中压入1，否则压入0 |
| i32.eq  | 从栈顶依次弹出2个i32的值，若二者相等，则在栈中压入1，否则压入0 |
| i32.ne | 从栈顶依次弹出2个i32的值，若二者不等，则在战中压入1，否则压入0 |
| i32.lt_s  | 从栈顶依次弹出1个i32的值a、1个i32的值b，若b小于a，则在栈中压入1，否则压入0。a和b都被认为是有符号整数 |
| i32.lt_u  | 从栈顶依次弹出1个i32的值a、1个i32的值b，若b小于a，则在栈中压入1，否则压入0。a和b都被认为是无符号整数。|
| i32.gt_s  | 从栈顶依次弹出1个i32的值a、1个i32的值b，若b大于a，则在栈中压入1，否则压入0。a和b都被认为是有符号整数。|
| i32.gt_u  | 从栈顶依次弹出1个i32的值a、1个i32的值b，若b大于a，则在栈中压入1，否则压入0。a和b都被认为是无符号整数。|
| i32.le_s  | 从栈顶依次弹出1个i32的值a、1个i32的值b，若b小于等于a，则在栈中压入1，否则压入0。a和b都被认为是有符号整数。|
| i32.le_u  | 从栈顶依次弹出1个i32的值a、1个i32的值b，若b小于等于a，则在栈中压入1，否则压入0。a和b都被认为是无符号整数。 |
| i32.ge_s  | 从栈顶依次弹出1个i32的值a、1个i32的值b，若b>=a，则在栈中压入1，否则压入0。a和b都被认为是有符号整数。 |
| i32.ge_u  | 从栈顶依次弹出1个i32的值a、1个i32的值b，若b>=a，则在栈中压入1，否则压入0。a和b都被认为是无符号整数。 |
| i64.eqz  | 从栈顶弹出1个i64的值v，若v为0，则在栈中压入1，否则压入0 |
| i64.eq  | 从栈顶依次弹出2个i64的值，若二者相等，则在栈中压入1，否则压入0 |
| i64.ne  | 从栈顶依次弹出2个i64的值，若二者不等，则在栈中压入1，否则压入0 |
| i64.lt_s  | 从栈顶依次弹出1个i64的值a、1个i64的值b，若b小于a，则在栈中压入1，否则压入0。a和b都被认为是有符号整数。 |
| i64.lt_u  | 从栈顶依次弹出1个i64的值a、1个i64的值b，若b小于a，则在栈中压入1，否则压入0。a和b都被认为是无符号整数。 |
| i64.gt_s  | 从栈顶依次弹出1个i64的值a、1个i64的值b，若b大于a，则在栈中压入1，否则压入0。a和b都被认为是有符号整数。 |
| i64.gt_u  | 从栈顶依次弹出1个i64的值a、1个i64的值b，若b大于a，则在栈中压入1，否则压入0。a和b都被认为是无符号整数。 |
| i64.le_s  | 从栈顶依次弹出1个i64的值a、1个i64的值b，若b小于等于a，则在栈中压入1，否则压入0。a和b都被认为是有符号整数。 |
| i64.le_u  | 从栈顶依次弹出1个i64的值a、1个i64的值b，若b小于等于a，则在栈中压入1，否则压入0。a和b都被认为是无符号整数。 |
| i64.ge_s  | 从栈顶依次弹出1个i64的值a、1个i64的值b，若b大于等于a，则在栈中压入1，否则压入0。a和b都被认为是有符号整数。 |
| i64.ge_u  | 从栈顶依次弹出1个i64的值a、1个i64的值b，若b大于等于a，则在栈中压入1，否则压入0。a和b都被认为是无符号整数。 |
| f32.eq  | 从栈顶依次弹出2个f32的值，若二者相等，则在栈中压入1，否则压入0 |
| f32.ne  | 从栈顶依次弹出2个f32的值，若二者不等，则在栈中压入1，否则压入0 |
| f32.lt  | 从栈顶依次弹出1个f32的值a、1个f32的值b，若b小于a，则在栈中压入1，否则压入0 |
| f32.gt  | 从栈顶依次弹出1个f32的值a、1个f32的值b，若b大于a，则在栈中压入1，否则压入0 |
| f32.le  | 从栈顶依次弹出1个f32的值a、1个f32的值b，若b小于等于a，则在栈中压入1，否则压入0。 |
| f32.ge  | 从栈顶依次弹出1个f32的值a、1个f32的值b，若b大于等于a，则在栈中压入1，否则压入0。 |
| f64.eq  | 从栈顶依次弹出2个f64的值，若二者相等，则在栈中压入1，否则压入0 |
| f64.ne  | 从栈顶依次弹出2个f64的值，若二者不等，则在栈中压入1，否则压入0 |
| f64.lt  | 从栈顶依次弹出1个f64的值a、1个f64的值b，若b小于a，则在栈中压入1，否则压入0。 |
| f64.gt  | 从栈顶依次弹出1个f64的值a、1个f64的值b，若b大于a，则在栈中压入1，否则压入0。 |
| f64.le  | 从栈顶依次弹出1个f64的值a、1个f64的值b，若b小于等于a，则在栈中压入1，否则压入0。 |
| f64.ge  | 从栈顶依次弹出1个f64的值a、1个f64的值b，若b大于等于a，则在栈中压入1，否则压入0。 |

### 7. 类型转换指令：

|    指令     | 描述 |
| ----------  | --- |
| i32.wrap_i64 | 从栈顶弹出1个i64的值v，高32位舍弃，将低32位的i32值压入栈 |
| i32.trunc_f32_s | 从栈顶弹出1个f32的值v，向0取整为有符号i32后压入栈。取值后的值如果超过有符号i32的值域则抛出WebAssembly.RuntimeError |
| i32.trunc_f32_u | 从栈顶弹出1个f32的值v，向0取整为无符号i32后压入栈。取值后的值如果超过无符号i32的值域则抛出WebAssembly.RuntimeError |
| i32.trunc_f64_s | 从栈顶弹出1个f64的值v，向0取整为有符号i32后压入栈。取值后的值如果超过有符号i32的值域则抛出WebAssembly.RuntimeError |
| i32.trunc_f64_u | 从栈顶弹出1个f64的值v，向0取整为无符号i32后压入栈。取值后的值如果超过无符号i32的值域则抛出WebAssembly.RuntimeError |

其中，向0取整即丢弃其小数部分，保留整数部分。

|    指令      | 描述 |
| ----------  | --- |
| i64.extend_i32_s | 从栈顶弹出1个i32的值v，按有符号整数拓展为i64压入栈 |
| i64.extend_i32_u | 从栈顶弹出1个i32的值v，按无符号整数拓展为i64压入栈 |
| i64.trunc_f32_s  | 从栈顶弹出1个f32的值v，向0取整为有符号i64后压入栈。取值后的值如果超过有符号i64的值域则抛出WebAssembly.RuntimeError |
| i64.trunc_f32_u  | 从栈顶弹出1个f32的值v，向0取整为无符号i64后压入栈。取值后的值如果超过无符号i64的值域则抛出WebAssembly.RuntimeError |
| i64.trunc_f64_s  | 从栈顶弹出1个f64的值v，向0取整为有符号i64后压入栈。取值后的值如果超过有符号i64的值域则抛出WebAssembly.RuntimeError |
| i64.trunc_f64_u  | 从栈顶弹出1个f64的值v，向0取整为无符号i64后压入栈。取值后的值如果超过无符号i64的值域则抛出WebAssembly.RuntimeError |

其中，有符号整数扩展为符号位扩展至最高位，其余填充0；无符号整数扩展为高位填充0。向0取整即丢弃其小数部分，保留整数部分。

|    指令      | 描述 |
| ----------  | --- |
| f32.convert_i32_s  | 从栈顶弹出1个i32的值v，将其转换为最接近的f32型的值后压入栈。v被视为有符号整数，转换过程可能丢失精度。 |
| f32.convert_i32_u  | 从栈顶弹出1个i32的值v，将其转换为最接近的f32型的值后压入栈。v被视为无符号整数，转换过程可能丢失精度。 |
| f32.convert_i64_s  | 从栈顶弹出1个i64的值v，将其转换为最接近的f32型的值后压入栈。v被视为有符号整数，转换过程可能丢失精度。 |
| f32.convert_i64_u  | 从栈顶弹出1个i64的值v，将其转换为最接近的f32型的值后压入栈。v被视为无符号整数，转换过程可能丢失精度。 |
| f32.demote_f64     | 从栈顶弹出1个f64的值v，将其转换为最接近的f32型的值后压入栈。转换过程可能丢失精度或溢出。 |
| f64.convert_i32_s  | 从栈顶弹出1个i32的值v，将其转换为最接近的f64型的值后压入栈。v被视为有符号整数。 |
| f64.convert_i32_u  | 从栈顶弹出1个i32的值v，将其转换为最接近的f64型的值后压入栈。v被视为无符号整数。 |
| f64.convert_i64_s  | 从栈顶弹出1个i64的值v，将其转换为最接近的f64型的值后压入栈。v被视为有符号整数，转换过程可能丢失精度。 |
| f64.convert_i64_u  | 从栈顶弹出1个i64的值v，将其转换为最接近的f64型的值后压入栈。v被视为无符号整数，转换过程可能丢失精度。 |
| f64.promote_f32    | 从栈顶弹出1个f32的值v，将其转换为f64型的值后压入栈。 |
| i32.reinterpret_f32 | 从栈顶弹出1个f32的值v，将其按位原样转为i32后压入栈 |
| i64.reinterpret_f64 | 从栈顶弹出1个f64的值v，将其按位原样转为i64后压入栈 |
| f32.reinterpret_i32 | 从栈顶弹出1个i32的值v，将其按位原样转为f32后压入栈 |
| f64.reinterpret_i64  | 从栈顶弹出1个i64的值v，将其按位原样转为f64后压入栈 |
### 8. 控制流指令：

|    指令     | 描述 |
| ----------  | --- |
| br n | 跳转至n指定的label索引的代码块的后续点，n为label别名或相对层数（即相对于当前代码块的嵌套深度）|
| br_if n | 从栈顶弹出1个i32的值v，若v不等于0，则执行br n |
| br_table L[n] L_Default | 从栈上弹出1个i32的值m，如果m小于n，则执行br L[m]，否则执行br L_Default。L[n]是一个长度为n的label索引数组。 |
| return  | 跳出函数 |
| call f | 根据f指定的函数的签名初始化参数并调用它，f为函数别名或函数索引 |
| call_indirect t | 从栈顶弹出1个i32的值n，根据t指定的函数签名初始化参数并调用表格中索引为n的函数。t为类型别名或类型索引。 |
| block/end  | block指令块 |
| loop/end  | loop指令块 |
| if/else/end  | if/else指令块 |


### 9. 其他指令

|    指令     | 描述 |
| ----------  | --- |
| unreachable  | 触发异常，抛出WebAssembly.RuntimeError |
| nop | 什么也不做 |
| drop | 从栈顶弹出1个值，无视类型 |
| select  | 依次从栈顶弹出1个i32的值c、1个值b、1个值a，若c部位0，则将a压入栈，否则将b压入栈。a和b必须为同一种类型 |
	
	
