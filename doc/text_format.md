## WebAssembly 文本格式

### 栈式机器

虽然浏览器把wasm编译为某种更高效的东西，但是，wasm 的执行是以栈式机器定义的。
也就是说，其基本理念是每种类型的指令都是栈上执行数值的入栈出栈操作。

### 基本原则

```wat
(module
    (func $getAnswer (result i32)
     i32.const 42)
     (func (export "getAnswerPlus1") (result i32)
        call $getAnswer
        i32.const 1
        i32.add
     )
)
```

注：i32.const 只是定义一个32位整数并把它压入栈。你可以把i32替换为任何其他可用的类型，并把const值修改为你想要的任何值

### WebAssembly 内存

为了处理字符串及其他复杂数据类型，WebAssembly 提供了内存。

按照 WebAssembly 的定义，内存就是一个随着时间增长的字节数组。WebAssembly 包含诸如 i32.load 和 i32.store 指令来实现对线性内存的读写。 

WebAssembly 定义一页为 64KB

### WebAssembly 表格

表格是从 WebAssembly 代码中通过索引获取的可变大小的引用数组

为了了解为什么表格是必须的，我们首先需要观察call指令，它接受一个静态函数索引，并且只调用了一个函数--但是，如果被调用者是一个运行时值呢？

* 在 JavaScript 中，函数是一等值
* 在 C/C++ 中，函数指针
* 在 C++ 中，有虚函数

WebAssembly 需要一种做到这一点的调用指令，因此，我们有了接受一个动态函数操作数的 call_indirect 指令。
问题是，在WebAssembly中，当前操作数的仅有的类型是 i32/i64/f32/f64

WebAssembly 可以增加一个 anyfunc 类型（“any”的含义是该类型能够持有任何签名的函数），但是，不幸的是，由于安全原因，这个anyfunc 类型不能存储在线性内存中。

`线性内存会把存储的原始内容作为字节暴露出去，并且这会使得wasm内容能够任意的查看和修改原始函数地址` 而这在网络上是不被允许的。 

解决方案是在一个表格中存储函数引用，然后作为 代替，传递表格索引——它们只是i32类型值。因此，call_indirect的操作数可以是一个i32类型索引值。

### 改变表格和动态链接

因为表格是可变的，所以，它们能够用来实现复杂的加载时和运行时动态链接。当程序被动态地链接，多个实例共享相同的内存和表格。这与原生应用程序的多个 .dll 共享一个进程地址空间是等价的。 

