## 虚拟机和解释器

Wasm 程序的执行环境是一台栈式虚拟机，绝大多数Wasm指令都要借助操作数栈来工作：从上面弹出若干数值，对数值进行计算，然后再把计算结果压栈。

* 操作数栈

* 虚拟机

* 指令循环

* 指令分派
wasm本身包含两部分信息：操作码和立即数（即指令的静态参数）。
对于解释器来说，通常有两个方式执行指令。一种是用一个长长的 switch-case 语句分派执行逻辑；
另一种是用查表的方式分派指令执行逻辑。

* 参数指令
drop 和 select

drop指令（0x1A）从栈顶弹出一个操作数并把它扔掉

select指令（0x1B）从栈顶弹出3个操作数，然后根据最先弹出的操作数和其他两个数中选择一个压栈。
最先弹出的操作数必须是i32类型，其他2个操作数是相同类型的就可以。如果最先弹出的操作数不为0，则把最后弹出的操作数压栈；如果为0，则把中间的操作数压栈。

* 数值指令
常量指令（4条）、测试指令（2条）、比较指令（32条）、一元算术指令（20条）、二元算术指令（44条）、类型转换指令（31条）

常量指令：i32.const(0x41) i64.const (0x42) f32.const(0x43) f64.const(0x44)

* 测试指令

测试指令从栈顶弹出一个操作数，先“测试”它是否为0，然后把测试结果（i32类型的布尔值）压栈。测试指令只有2条，对应2种整数类型：i32.eqz（操作码0x45）和i64.eqz（操作码0x50）

* 比较指令

比较指令从栈顶弹出2个同类型的操作数进行比较，然后把比较结果（i32类型的布尔值）压栈。比较指令数量比较多，针对2种整数类型各有10条，针对2种浮点数类型各有6条，一共是32条。可以进行的比较包括等于（eq）、不等于（ne）、小于（It）、大于（gt）、小于等于（le）、大于等于（ge）。

* 一元算术指令

一元算术指令从栈顶弹出一个操作数进行计算，然后将同类型的结果压栈。

整数一元算术指令共6条，i32和i64整数类型各3条。这些指令用于统计整数的前导0比特数、后置0比特数、1比特数。以i32整数为例，假设栈顶操作数为0x0000F0F0，则其前导0比特数是16，后置0比特数是4，1比特数是8。

（clz表示Count Leading Zeros，ctz表示Count Trailing Zeros，popcnt表示Population Count）

* 二元算术指令
二元算术指令从栈顶弹出2个相同类型的操作数进行计算，然后将同类型结果压栈。
整数二元算术指令共30条，每种整数类型15条。这些指令可实现加、减、乘、除以及最大值和最小值运算。

* 类型转换指令
类型转换指令从栈顶弹出一个操作数进行类型转换，然后把结果压栈。按照转换方式，可以把类型转换指令进一步分为6小类。
1. 整数截断（wrap）
把64位整数截断为32位，只有1条指令

2. 整数拉升（extend）
把32位整数拉升为64位，共2条指令（i64.extend_i32_s/u），对应2种符号类型；或者对小整数（char、short、int）进行符号扩展，共5条指令（i32/64.extend8/16/32_s，由符号扩展提案建议增加）

3. 浮点数截断（trunc）
把浮点数截断为整数，共9条指令。其中1条是饱和截断指令

4. 整数转换（convert）
把整数转换为浮点数，共8条指令。

5. 浮点数精度调整（demote、promote）
把浮点数截断为整数，共9条指令。其中1条是饱和截断指令

6. 比特位重新解释（reinterpret）
不改变操作数比特位，仅重新解释类型，共4条指令。

截断指令
上溢出（Overflow）和下溢出（Underflow）

对于溢出，通常有3种处理方式。

第一种是环绕（Wrapping）
整数运算通常采用这种方式。以u32类型为例，0xFFFFFFFD和0x04相加导致溢出，结果为0x01。

第二种是饱和（Saturation）
浮点数运算通常采用这种方式，超出范围的值会被表示为正或负“无穷”（±Inf）

第三种是异常
例如整数除 0 通常会产生异常






